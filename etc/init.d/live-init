#!/live/bin/sh

### BEGIN INIT INFO
# Provides:          live-init
# Required-Start:    checkroot checkroot-bootclean
# Required-Stop:
# Should-Start:
# Should-Stop:
# Default-Start:     S
# Default-Stop:
# Short-Description: live-init
# Description: localize /etc/skel, create /home/demo, customize X, mirrors, set default desktop
### END INIT INFO

export PATH=/sbin:/usr/sbin:/bin:/usr/bin:/usr/local/bin

XSESSION_DIR=/usr/share/xsessions
    MENU_WMs="fluxbox icewm jwm"
    FF_PREFS="/etc/skel/.mozilla/firefox/*/prefs.js"
   AUTOMOUNT=
   EARLY_VID=
   FOUND_KMS=

ALL_VIDEO_MODULES="ast|cirrus|gma500_gfx|ch7006|sil164|tda998x|i810|i915|mga|mgag200|nouveau|qxl|r128|radeon|savage|sis|tdfx|ttm|udl|via|vmwgfx"

KMS_VIDEO_MODULES="ast|cirrus|gma500_gfx|ch7006|tda998x|i915|mgag200|nouveau|qxl|radeon|udl|vmwgfx"

#-jbb For debugging
: ${CMDLINE:=$(cat /proc/cmdline /live/config/cmdline)}
for param in $CMDLINE; do
    value=${param#*=}
    case "$param" in
                   db+)      DB_PLUS=true                           ;;
             desktop=*)  CMD_DESKTOP=$value                         ;;
                 dpi=*)      CMD_DPI=$value                         ;;
                 kbd=*)      CMD_KBD=$value ;          DO_XKBD=true ;;
               kbopt=*)   XKBOPTIONS=$value ;          DO_XKBD=true ;;
               kbvar=*)   XKBVARIANT=$value ;          DO_XKBD=true ;;
                lang=*)     CMD_LANG=$value ;          DO_XKBD=true ;;
                  tz=*)       CMD_TZ=$value                         ;;
              mirror=*)   CMD_MIRROR=$value                         ;;
         hwclock=local)    CMD_CLOCK=$value                         ;;
           hwclock=utc)    CMD_CLOCK=$value                         ;;

              failsafe)   XORG_ARGS=safe${XORG_ARGS:+,}$XORG_ARGS   ;;
             xorg=safe)   XORG_ARGS=safe${XORG_ARGS:+,}$XORG_ARGS   ;;
                xorg=*)   XORG_ARGS=$XORG_ARGS${XORG_ARGS:+,}$value ;;
                noxorg)   NO_XORG=true                              ;;
              earlyvid)   EARLY_VID=true                            ;;
            noearlyvid)   EARLY_VID=                                ;;

automount=off|amnt=off)                          AUTOMOUNT_OFF=true ;;
        automount|amnt)                              AUTOMOUNT=true ;;
    automount=*|amnt=*)    CMD_MOUNT=$value ;        AUTOMOUNT=true ;;
               mount=*)    CMD_MOUNT=$value ;        AUTOMOUNT=true ;;
               fstab=*)    CMD_FSTAB=$value                         ;;
                splash) SPLASH_PARAM=v                              ;;
              splash=*) SPLASH_PARAM=$value                         ;;
           desktheme=*) DESK_THEME=$value                           ;;
    esac
done

umask 022

. /live/lib/live-init-utils.sh

start_init_logging
load_translation

main() {
    case "$1" in
        start)
            do_start
            ;;
        stop)
            exit 0
            ;;
        *)
            echo "Usage: $0 {start|stop}"
            exit 1
            ;;
    esac
}

#----- Main code starts here --------------------------------------------------

do_start() {
    echo_script "Localizing/configuring X-Windows" $0

    get_init_param DISTRO "unknown"

    case $DISTRO in
        antiX) automount_and_fstab;;
      MX|MX-*) add_fstab_swap     ;;
            *) error 'Unknown_distro %s' "$(pquote $DISTRO)"
    esac

    #-jbb: for debugging
    unset COUNTRY WM_LANG KEYBOARDS KEYTABLE LANG MIRROR TZ XKBLAYOUT CONSOLE_FONT

    get_init_lang "$CMD_LANG" error

    repo_localize "$CMD_MIRROR" "$CMD_TZ" "$MIRROR" "$TZ"

    localize_skel $WM_LANG

    # Always create keyboard file in non-perisistent system even with no X
    kb_file=/etc/default/keyboard
    default_xkb_opts="grp:alt_shift_toggle,terminate:ctrl_alt_bksp,grp_led:scroll"

    if first_write $kb_file || [ "$DO_XKBD" ]; then
        XKBLAYOUT=${CMD_KBD:-$XKBLAYOUT}
        [ "$XKBLAYOUT"  ] && echo_live "Setting %s to %s" $(pquote xkb-layout)  $(pquote $XKBLAYOUT)
        [ "$XKBMODEL"   ] && echo_live "Setting %s to %s" $(pquote xkb-model)   $(pquote $XKBMODEL)
        [ "$XKBVARIANT" ] && echo_live "Setting %s to %s" $(pquote xkb-variant) $(pquote $XKBVARIANT)
        [ "$XKBOPTIONS" ] && echo_live "Setting %s to %s" $(pquote xkb-options) $(pquote $XKBOPTIONS)

        cat > $kb_file <<Keyboard_Out
XKBMODEL="${XKBMODEL:=pc105}"
XKBLAYOUT="${XKBLAYOUT:=us}"
XKBVARIANT="${XKBVARIANT}"
XKBOPTIONS="${XKBOPTIONS:=$default_xkb_opts}"
Keyboard_Out
    fi

    [ "$CMD_CLOCK"   ] && set_utc_local $CMD_CLOCK

    # Only do X stuff on systems that seem to have X
    if which X &>/dev/null; then

        [ "$CMD_DPI" ] && set_dpi $CMD_DPI

        if [ "$EARLY_VID" ]; then
            load_video_driver
        else
            detect_kms_driver
        fi

        make_xorg_conf "$XORG_ARGS" "$FOUND_KMS"
        HAVE_X=true
    fi

    # Find the "default" user.  This is usually "demo" but can vary on snapshots
    # and such.  First check the default user for SLiM and lightdm.  Then get
    # more desparate.

    THE_USER=$(sed -r -n 's/^\s*default_user\s+//p' /etc/slim.conf 2>/dev/null)
    : ${THE_USER:=$(sed -r -n 's/^\s*autologin-user=//p' /etc/lightdm/lightdm.conf 2>/dev/null)}
    : ${THE_USER:=$(getent passwd 1000 | cut -d: -f1)}
    : ${THE_USER:=demo}
    THE_USER=${THE_USER%% *}

    USER_HOME=$(getent passwd $THE_USER | cut -d: -f6)

    if [ -z "$USER_HOME" ]; then
        echo_live "No default user %s found on the system." $(pquote $THE_USER)
        return
    fi

    create_home $THE_USER $USER_HOME

    # Don't bother with desktop stuff on systems without X
    #--------------------------------------------------------------------------
    [ "$HAVE_X" ] || return
    #--------------------------------------------------------------------------

    [ "$CMD_DESKTOP" ] && set_default_desktop $CMD_DESKTOP $THE_USER $USER_HOME

    if [ "$DESK_THEME" ]; then
        echo_live "Setting desktop theme to %s" $(pquote  $DESK_THEME)
        set-desktop-theme --root $DESK_THEME
        su -c "set-desktop-theme --dir $USER_HOME $DESK_THEME" $THE_USER
    fi

    #localize_firefox $LANG
}

create_home() {
    local user=$1 home=$2

    # Remove only an *empty* home directory
    rmdir $home 2>/dev/null
    if test -d $home; then
        return
        # These don't run but the don't leave the .pot file either
        echo_live "Files already exist under %s" $(pquote $home)
        echo_live "Not creating or populating %s" $(pquote $home)
    fi

    echo_live "Populating %s directory" $(pquote $home)
    # Relies on there being no $home directory (see test above)
    cp -a /etc/skel $home
    chown -R $user:users $home
}

localize_skel() {
    local lang=$1
    [ "$lang" ] || return
    local L10n_dir=/usr/share/antiX/localisation
    local from=$L10n_dir/$lang
    local dest=/etc/skel

    # Silently skip systems which have no localisation directory
    [ -d "$L10n_dir" ] || return

    if ! [ -d $from ]; then
        error "Unknown menu localization language %s" $(pquote $lang)
        error "Directory not found %s" $from
        return
    fi

    echo_live "Localizing menus to %s in %s" $(pquote $0) $(pquote $dest)

    # Basically a cp -a but make all top level files and directories hidden
    for file in $(ls $from); do
       if [ -d $from/$file ]; then
           mkdir -p /$dest/.$file
           cp -a $from/$file/* $dest/.$file
       else
           rm -rf $dest/.$file
           cp -a $from/$file $dest/.$file
       fi
    done
}

#FIXME:
localize_firefox() {
    local pref_files file lang=$1
    local string="user_pref(\"spellchecker.dictionary\","

    pref_files=$(ls $FF_PREFS 2>/dev/null)
    [ "$pref_files" ] || return
    sed -i  "/$string/d" $pref_files
    for file in $pref_files; do
        echo "$string \"$lang\");" >> $file
    done
}

set_dpi() {
    local dpi=$1

    if ! echo $dpi | grep -q "^[[:digit:]]\+$"; then
        error "Invalid %s boot parameter %s" $(pquote dpi) $(pquote $dpi)
        return
    fi

    echo_live "Setting %s to %s" $(pquote dpi) $(pquote $dpi)

    local file
    for file in /etc/slim.conf /usr/share/slim/themes/antiX/slim-install.conf; do
        [ -e $file ] || continue
        sed -i -e "s/^xserver_arguments.*/xserver_arguments -dpi $dpi -nolisten tcp/" $file
    done

    for file in /etc/lightdm/lightdm.conf; do
        [ -e $file ] || continue
        sed -i -r "s/^#?\s*(xserver-command=X).*/\1 -dpi $dpi/" $file
    done
}

repo_localize() {
    local mirror=$1  tz=$2  lang_mirror=$3  lang_tz=$4

    if [ -n "$mirror" -a -n "${mirror##[a-zA-Z][a-zA-Z]}" ]; then
        error "Bad mirror code %s (expected two letters)" $(pquote $mirror)
        mirror=
    fi

    local arg=$mirror         # cheat mirror=xx overides all else
    : ${arg:=$tz}             # next come tz=xxx/yyy cheat (or via tz menu)
    : ${arg:=$lang_tz}        # The lang based timezone
    : ${arg:=$lang_mirror}    # The lang based mirror should never be needed

    [ "$arg" ] || return

    sources_dir=/etc/apt/sources.list.d
    first_write $sources_dir || [ "$mirror" -o "$tz" ] || return

    local verbose
    [ "$DB_PLUS" ] && verbose=--verbose

    echo_live "Localizing source repos using %s" $(pquote $arg)
    repo-localize $verbose $arg
}

set_utc_local() {
    local new=$1 file=/etc/adjtime
    #grep -i -q $new $file && return

    echo_live "Assuming %s is set to %s time" hwclock $(pquote $new)

    case $new in
        local) sed -i 's/^UTC\s*$/LOCAL/' $file
               hwclock --hctosys --localtime      ;;
          utc) sed -i 's/^LOCAL\s*$/UTC/' $file
               hwclock --hctosys --utc            ;;
    esac
}

set_default_desktop() {
    local desktop=$1  user=$2  home=$3
    local file=$home/.desktop-session/default-desktop
    echo_live "Setting %s to %s" desktop $(pquote $desktop)
    su -c "mkdir -p $(dirname $file)" $user
    echo $desktop | su -c "tee $file" $user >/dev/null
}

add_fstab_swap() {
    echo_live 'Possibly adding swap partitions to fstab'
    make-fstab --quiet --swap-only
}

automount_and_fstab() {

   local        am_file=/etc/fstab.automount
   local     mount_file=/etc/fstab.mount
   local        hp_file=/etc/fstab.hotplug
   local  hp_state_file=$hp_file.state

    # Delay start of auto-stuff until after udev has started
    rm -f /etc/udev/rules.d/90-fstab-automount.rules

    # "off" means "off"
    if [ "$CMD_MOUNT" = 'off' -o -n "$AUTOMOUNT_OFF" ]; then
        echo_live "Turning all boot mount options off"
        rm -f $mount_file
        CMD_MOUNT=

        if [ -n "$AUTOMOUNT_OFF" ]; then
            echo_live "Turning automount off"
            AUTOMOUNT=
            rm -f $am_file
        fi
    fi

    # Read in previous value (persistent systems only)
    if [ -z "$CMD_MOUNT" -a -e $mount_file ]; then
        CMD_MOUNT=$(cat $mount_file)
    else
        [ "$CMD_MOUNT" ] && echo $CMD_MOUNT > $mount_file
    fi

    # Mount partitions while building fstab file
    local fstab_opt=
    case ",$CMD_MOUNT" in
        ,all)
            echo_live "Mounting all devices"
            fstab_opt="$fstab_opt --mount=$CMD_MOUNT" ;;
        ,usb)

            echo_live "Mounting usb devices"
            fstab_opt="$fstab_opt --mount=$CMD_MOUNT" ;;

        ,)  ;;
        *)  error "Invalid %s option %s" 'mount/automount' $(pquote $CMD_MOUNT) ;;
    esac

    if [ -e /etc/fstab  ]; then
        grep -q -e ^/dev -e ^UUID= -e ^LABEL=  /etc/fstab || rm /etc/fstab
    fi

    make-fstab --quiet $fstab_opt

    [ "$AUTOMOUNT" ] && touch $am_file

    if [ -e $am_file ]; then
        echo_live "Automount enabled"
    else
        echo_live "Automount disabled"
    fi

    # The hp_file is removed by /init
    # The hp_state_file carries over "off" setting on persistent systems
    [ -z "$CMD_FSTAB" -a -e $hp_state_file ] && CMD_FSTAB=$(cat $hp_state_file)

    case ",$CMD_FSTAB" in
        ,off)
            echo_live "Disabling fstab hotplugging (this will also disable automount)"
            echo $CMD_FSTAB > $hp_state_file
            rm -f $hp_file  ;;

        ,on|,)
            echo_live "Enabling fstab hotplugging"
            rm -f $hp_state_file
            touch $hp_file;;

        *)
            error "Bad fstab option %s" $(pquote $CMD_FSTAB)
            echo_live "Enabling fstab hotplugging"
            touch $hp_file;;
    esac
}

# Don't make a default xorg.conf if:
#    1) a modified xorg.conf is found
#    2) "noxorg" was specified
#    3) a kms driver was found (regardless of "nomodeset")
#    4) there is no frame buffer
#    3) there is a frame buffer other than vesa

make_xorg_conf() {
    local args=$1 found_kms=$2 safe_mode= xorg_conf=/etc/X11/xorg.conf

    case ,$args, in
        *,safe,*) safe_mode=true;;
    esac
    #- # Disable fbdev unless it is specifically requested
    #- # If it is requested then make sure it is enabled (by us at least)
    #- local fbdev=/usr/lib/xorg/modules/drivers/fbdev_drv.so
    #- local fbdev2=/usr/local/lib/xorg/fbdev_drv.so
    #- case ,$args, in
    #-     *,fbdev,*)  move_if $fbdev2 $fbdev ;;
    #-             *)  move_if $fbdev $fbdev2 ;;
    #- esac

    # Always erase generated xorg.conf files
    if test -f $xorg_conf && grep -q "*#\s*Generated by\s*make-xorg-conf" $xorg_conf; then
        echo_live "Removing previous auto-generated %s file" $(pquote xorg.conf)
        rm -f $xorg_conf
    fi

    local no_default
    test -e $xorg_conf             && no_default=true
    [ "$NO_XORG" ]                 && no_default=true
    [ "$FOUND_KMS" ]               && no_default=true
    [ -e /live/config/virtualbox ] && no_default=true

    # safe mode from the user over-rides vbox mode
    [ -z "$safe_mode" -a -e /live/config/virtualbox ] && args=vbox${args:+,}$args

    # Check who is creating the framebuffer (in any)
    local vga_fb fb_name=none
    read fb_name 2>/dev/null < /sys/class/graphics/fb0/name

    case $fb_name in
      "VESA VGA") vga_fb=true ;;
       "EFI VGA") if [ "$safe_mode" ]; then
                    echo_live "Disabling safe mode because of %s" $(pquote EFI framebuffer)
                    safe_mode=
                fi ;;
    esac

    # Force X video driver to be vesa if the vga framebuffer is enabled.
    if  [ "$vga_fb" -a -z "$no_default" -a -z "$safe_mode" ]; then
        echo_live "Forcing X-windows to use default mode"
        args=default${args:+,}$args
    fi

    [ "$args" ] || return

    echo_live "Configuring %s file with %s" $(pquote $xorg_conf) $(pquote $args)
    backup_file $xorg_conf
    /sbin/make-xorg-conf --output=$xorg_conf $args
}

find_video_modules() {
    local modules=${1:-$ALL_VIDEO_MODULES}
    find /sys/devices -name modalias -print0 | xargs -0 sort -u \
        | xargs modprobe -a -D -q 2>> $INIT_LOG_FILE | sort -u \
        | sed -n -r "s/^insmod [^ ]*($modules)\.ko.*/\1/p"
}

set_fbcondecor() {
    local boot_param=$1 orig_name=$2 param verbose theme=default new_name
    #[ "$orig_name"  ] || return
    [ "$boot_param" ] || return

    # Don't set the decoration if the framebuffer has not changed
    read new_name= 2>/dev/null < /sys/class/graphics/fb0/name
    [ "$orig_name" = "$new_name" ] && return

    for param in $(echo $boot_param | sed "s/,/ /g"); do
        case $param in
            v|verbose) verbose=true ;;
          t=*|theme=*) theme=${param#*=} ;;
        esac
    done

    # Only set bg if we are in verbose mode
    [ "$verbose" ] || return
    /sbin/splash-term $theme
}

load_video_driver() {
    local orig_fb_name
    read orig_fb_name 2</dev/null < /sys/class/graphics/fb0/name
    echo_live "Scanning for hardware specific video modules ..."
    local video_modules="$(find_video_modules)"
    local kms_modules="$(echo "$video_modules" | egrep "^($KMS_VIDEO_MODULES)$")"

    if [ "$kms_modules" ]; then
        echo_live "Found %s video module(s) %s" KMS "$(pquote $(echo $kms_modules))"
        echo_live "Load module(s) %s" "$(pquote $(echo $kms_modules))"
        modprobe -b -a -q "$kms_modules"
        set_fbcondecor "$SPLASH_PARAM" "$orig_fb_name"
    elif [ "$video_modules" ]; then
        echo_live "Found video module(s) %s" "$(pquote $(echo $video_modules))"
    fi
}

# Note: we will report FOUND_KMS even if "nomodeset" is used because unless the
# user wants safe mode then they should be allowed to use the KMS driver and
# "nomodeset" without us forcing vesa.  That's what safe mode is for.
detect_kms_driver() {
    local kms_drivers=$(find_video_modules "$KMS_VIDEO_MODULES|drm_kms_helper")
    [ "$kms_drivers" ] || return
    echo_live "Found %s video module(s) %s" KMS ""
    FOUND_KMS=true
}

# Always copy to $file$ext2 so this has the most recent backup.
# Only move to $file$ext1 if it does not already exist so this will
# contain the earliest (oldest) backup.
backup_file() {
    local file=$1 ext1=${2:-.old} ext2=${3:-save}

    test -e $file || return
    cp -f $file $file$ext2
    test -e $file$ext1 && return
    mv -f $file $file$ext1
}

move_if() {
    local f1=$1  f2=$2
    test -e $f1 || return
    mkdir -p $(dirname $f2)
    mv -f $f1 $f2
}

main "$@" 2>&1 | tee -a $INIT_LOG_FILE

exit 0
